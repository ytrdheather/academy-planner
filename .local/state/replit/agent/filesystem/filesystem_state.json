{"file_contents":{"main.py":{"content":"","size_bytes":0},"notion-client.js":{"content":"import { Client } from '@notionhq/client';\n\nlet connectionSettings;\n\nasync function getAccessToken() {\n  if (connectionSettings && connectionSettings.settings.expires_at && new Date(connectionSettings.settings.expires_at).getTime() > Date.now()) {\n    return connectionSettings.settings.access_token;\n  }\n  \n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME\n  const xReplitToken = process.env.REPL_IDENTITY \n    ? 'repl ' + process.env.REPL_IDENTITY \n    : process.env.WEB_REPL_RENEWAL \n    ? 'depl ' + process.env.WEB_REPL_RENEWAL \n    : null;\n\n  if (!xReplitToken) {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl');\n  }\n\n  connectionSettings = await fetch(\n    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=notion',\n    {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    }\n  ).then(res => res.json()).then(data => data.items?.[0]);\n\n  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token;\n\n  if (!connectionSettings || !accessToken) {\n    throw new Error('Notion not connected');\n  }\n  return accessToken;\n}\n\n// WARNING: Never cache this client.\n// Access tokens expire, so a new client must be created each time.\n// Always call this function again to get a fresh client.\nexport async function getUncachableNotionClient() {\n  const accessToken = await getAccessToken();\n  return new Client({ auth: accessToken });\n}","size_bytes":1506},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":157},"replit.md":{"content":"# Overview\n\nThis is a comprehensive student learning planner web application designed for Vercel deployment. The system features a multi-user teacher dashboard with role-based access control, full Notion database integration, and JWT-based authentication optimized for serverless environments. Students can log daily study progress including test results, homework verification, and reading activities, while teachers can monitor progress through filtered dashboards based on their assigned responsibilities.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Vercel Serverless Structure\nThe application is optimized for Vercel's serverless platform:\n- `api/index.js` - Main Express app exported as serverless function\n- `public/views/` - Static HTML files served directly\n- `vercel.json` - Routing configuration for serverless deployment\n- JWT-based authentication replacing memory sessions for serverless compatibility\n\n## Multi-User Authentication System\nImplements role-based access control with 7 distinct user accounts:\n- **Manager (1)**: Full system access and student management\n- **Teachers (4)**: Access to assigned students only\n- **Assistants (2)**: Limited read-only permissions\n- JWT tokens stored in localStorage with automatic expiration handling\n- Session regeneration on login for security\n\n## Permission System\n- **Manager**: All students + administrative functions\n- **Teacher**: Assigned students + progress management\n- **Assistant**: Limited viewing capabilities\n- Server-side filtering based on user roles and assignments\n- Activity logging for accountability\n\n## Database Integration\n- Notion API integration for student data and progress tracking\n- Graceful fallback to sample data when Notion is unavailable\n- Support for both Replit connector authentication and direct API keys\n- Smart book title autocomplete for English and Korean reading lists\n\n## Security Features\n- Environment variable validation for production deployments\n- JWT secret requirement in production environments\n- Protection against session fixation attacks\n- Secure token storage and automatic cleanup on logout\n\n## Deployment Architecture\n- **Primary Target**: Vercel serverless platform\n- **Development**: Replit environment with full debugging\n- **Runtime**: Node.js 18+ with ES6 modules\n- **Authentication**: JWT-based for serverless compatibility\n- **Static Assets**: Served directly by Vercel CDN\n\n## Environment Configuration\n- `JWT_SECRET`: Required for production token signing\n- `STUDENT_DATABASE_ID` & `PROGRESS_DATABASE_ID`: Notion database connections\n- `REPLIT_CONNECTORS_HOSTNAME`: For Replit-based Notion authentication\n- Automatic fallback to sample data for development testing\n\n# External Dependencies\n\n## Notion API\n- **@notionhq/client** (v5.1.0): Official Notion JavaScript SDK for database and page operations\n- Requires OAuth access tokens for authentication\n- Used for all Notion workspace interactions\n\n## JWT Authentication\n- **jsonwebtoken** (v9.0.2): JWT token generation and verification\n- Stateless authentication suitable for serverless environments\n- 24-hour token expiration with automatic refresh\n\n## Replit Connectors (Development Only)\n- Replit's internal connector system for OAuth management\n- Hostname resolution through `REPLIT_CONNECTORS_HOSTNAME` environment variable\n- Token-based authentication with Replit's API endpoints\n- Automatic credential refresh and secure storage\n\n## Vercel Environment Variables\nRequired for production deployment:\n- `JWT_SECRET`: Strong random string for token signing (REQUIRED)\n- `NOTION_ACCESS_TOKEN`: Notion integration token from https://www.notion.so/my-integrations (REQUIRED)\n- `NODE_ENV`: Set to 'production' for deployment\n- `STUDENT_DATABASE_ID`: Notion student database ID (optional - uses sample data if missing)\n- `PROGRESS_DATABASE_ID`: Notion progress database ID (optional - uses sample data if missing)\n\n# User Accounts\n\n## Login Credentials (All use same password: rdtd112!@)\n- `manager` - 매니저 (전체 관리)\n- `teacher1` - 선생님1 (담당 학생)\n- `teacher2` - 선생님2 (담당 학생)  \n- `teacher3` - 선생님3 (담당 학생)\n- `teacher4` - 선생님4 (담당 학생)\n- `assistant1` - 아르바이트1 (제한적 권한)\n- `assistant2` - 아르바이트2 (제한적 권한)\n\n# Deployment Guide\n\n## Vercel Deployment Steps\n1. **Create Notion Integration**:\n   - Go to https://www.notion.so/my-integrations\n   - Create new integration and copy the token\n   - Share your Notion databases with the integration\n\n2. **Connect GitHub repository to Vercel**\n\n3. **Set environment variables in Vercel dashboard**:\n   - `JWT_SECRET`: Generate strong random string (use openssl rand -base64 32)\n   - `NOTION_ACCESS_TOKEN`: Your Notion integration token\n   - `NODE_ENV`: production\n   - Optional: `STUDENT_DATABASE_ID` and `PROGRESS_DATABASE_ID`\n\n4. **Deploy with zero configuration** (vercel.json handles routing)\n\n5. **Access deployed application** at Vercel provided URL\n\n**Note**: The app works with or without Notion databases - it uses sample data for testing when databases are not configured.\n\n## Local Development\n- Runs on port 5000 in Replit environment\n- Automatic Notion connection testing\n- JWT tokens work with development fallback\n- All static files served properly","size_bytes":5333},"server.js":{"content":"import express from 'express';\nimport cors from 'cors';\nimport bodyParser from 'body-parser';\nimport session from 'express-session';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { getUncachableNotionClient } from './notion-client.js';\n\n// getAccessToken 함수 추가 (notion-client.js에서 가져오기)\nasync function getAccessToken() {\n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME\n  const xReplitToken = process.env.REPL_IDENTITY \n    ? 'repl ' + process.env.REPL_IDENTITY \n    : process.env.WEB_REPL_RENEWAL \n    ? 'depl ' + process.env.WEB_REPL_RENEWAL \n    : null;\n\n  if (!xReplitToken) {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl');\n  }\n\n  const connectionSettings = await fetch(\n    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=notion',\n    {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    }\n  ).then(res => res.json()).then(data => data.items?.[0]);\n\n  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token;\n\n  if (!connectionSettings || !accessToken) {\n    throw new Error('Notion not connected');\n  }\n  return accessToken;\n}\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\nconst PORT = 5000;\n\n// 미들웨어 설정\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production' ? false : 'http://localhost:5000',\n  credentials: true\n}));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(express.static('public'));\napp.use('/assets', express.static('assets'));\napp.use(session({\n  secret: process.env.SESSION_SECRET || 'readitude-secret-key-change-in-production',\n  resave: false,\n  saveUninitialized: false,\n  cookie: { \n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 24 * 60 * 60 * 1000 // 24시간\n  }\n}));\n\n// 환경 변수 검증 (필수)\nconst requiredEnvVars = {\n  STUDENT_DATABASE_ID: '학생 로그인 정보 데이터베이스',\n  PROGRESS_DATABASE_ID: '학습 진도 데이터베이스',\n  TEACHER_ACCESS_TOKEN: '선생님 접근 토큰'\n};\n\nconst missingVars = Object.keys(requiredEnvVars).filter(key => !process.env[key]);\nif (missingVars.length > 0 && process.env.NODE_ENV === 'production') {\n  console.error('❌ 프로덕션 환경에서 필수 환경 변수가 설정되지 않았습니다:');\n  missingVars.forEach(key => {\n    console.error(`   ${key}: ${requiredEnvVars[key]}`);\n  });\n  console.error('   이 변수들을 설정한 후 서버를 다시 시작하세요.');\n  process.exit(1);\n} else if (missingVars.length > 0) {\n  console.warn('⚠️  개발 환경: 일부 환경 변수가 설정되지 않았습니다 (기본값 사용):');\n  missingVars.forEach(key => {\n    console.warn(`   ${key}: ${requiredEnvVars[key]}`);\n  });\n}\n\n// 데이터베이스 ID를 Notion 형식으로 변환하는 함수\nfunction formatNotionId(id) {\n  // 대시가 없는 경우 Notion 형식으로 변환 (8-4-4-4-12)\n  if (id && !id.includes('-') && id.length === 32) {\n    return `${id.substring(0, 8)}-${id.substring(8, 12)}-${id.substring(12, 16)}-${id.substring(16, 20)}-${id.substring(20, 32)}`;\n  }\n  return id;\n}\n\n// 학생 데이터베이스 ID (원생 관리)  \nconst STUDENT_DB_ID = formatNotionId(process.env.STUDENT_DATABASE_ID || '25409320bce280f8ace1ddcdd022b360');\nconst PROGRESS_DB_ID = formatNotionId(process.env.PROGRESS_DATABASE_ID || '25409320bce2807697ede3f1c1b62ada');\nconst BOOK_LIST_DB_ID = formatNotionId(process.env.BOOK_LIST_DATABASE_ID || '9ef2bbaeec19466daa0d0c0677b9eb90');\nconst SAYU_BOOK_DB_ID = formatNotionId(process.env.SAYU_BOOK_DATABASE_ID || 'cf82d56634574d7e83d893fbf1b1a4e3');\n\n\n\n// 데이터베이스 연결 확인 완료\n\n\n// 사유독평 책 제목 자동완성 API (3독 독서용)\napp.get('/api/search-sayu-books', async (req, res) => {\n  const { query } = req.query;\n  \n  try {\n    if (!query || query.length < 2) {\n      return res.json([]);\n    }\n    \n    const accessToken = await getAccessToken();\n    \n    // 사유독평 합본 리스트에서 검색\n    const response = await fetch(`https://api.notion.com/v1/databases/${SAYU_BOOK_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          property: '3독 요약 사유독평 도서 보유 목록',\n          title: {\n            contains: query\n          }\n        },\n        sorts: [\n          {\n            property: '3독 요약 사유독평 도서 보유 목록',\n            direction: 'ascending'\n          }\n        ],\n        page_size: 10\n      })\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('사유독평 도서 검색 API 상세 오류:', errorText);\n      throw new Error(`사유독평 도서 검색 실패: ${response.status} - ${errorText}`);\n    }\n    \n    const data = await response.json();\n    \n    const books = data.results.map(page => {\n      const title = page.properties['3독 요약 사유독평 도서 보유 목록']?.title?.[0]?.plain_text || '';\n      const author = page.properties[' 지은이']?.rich_text?.[0]?.plain_text || '';\n      const publisher = page.properties[' 출판사']?.rich_text?.[0]?.plain_text || '';\n      \n      return {\n        title,\n        author,\n        publisher,\n        display: author ? `${title} (${author})` : title\n      };\n    }).filter(book => book.title && book.title.toLowerCase().includes(query.toLowerCase()));\n    \n    res.json(books);\n  } catch (error) {\n    console.error('사유독평 책 검색 오류:', error);\n    res.status(500).json({ error: '책 검색 중 오류가 발생했습니다.' });\n  }\n});\n\n// 영어 원서 제목 자동완성 API\napp.get('/api/search-books', async (req, res) => {\n  const { query } = req.query;\n  \n  try {\n    if (!query || query.length < 2) {\n      return res.json([]);\n    }\n    \n    const accessToken = await getAccessToken();\n    \n    // 리디튜드 영통 도서리스트에서 검색\n    const response = await fetch(`https://api.notion.com/v1/databases/${BOOK_LIST_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          property: 'Title',\n          title: {\n            contains: query\n          }\n        },\n        sorts: [\n          {\n            property: 'Title',\n            direction: 'ascending'\n          }\n        ],\n        page_size: 10\n      })\n    });\n    \n    if (!response.ok) {\n      const errorText = await response.text();\n      console.error('도서 검색 API 상세 오류:', errorText);\n      throw new Error(`도서 검색 실패: ${response.status} - ${errorText}`);\n    }\n    \n    const data = await response.json();\n    const books = data.results.map(page => {\n      const title = page.properties.Title?.title?.[0]?.plain_text || '';\n      const level = page.properties.Level?.select?.name || '';\n      const series = page.properties.Series?.rich_text?.[0]?.plain_text || '';\n      \n      return {\n        title,\n        level,\n        series,\n        display: level ? `${title} (${level})` : title\n      };\n    }).filter(book => book.title && book.title.toLowerCase().includes(query.toLowerCase())); // 클라이언트 사이드에서도 한번 더 필터링\n    \n    res.json(books);\n    \n  } catch (error) {\n    console.error('책 검색 오류:', error);\n    res.status(500).json({ error: '책 검색 중 오류가 발생했습니다.' });\n  }\n});\n\n// 로그인 페이지\napp.get('/', (req, res) => {\n  if (req.session.studentId) {\n    return res.redirect('/planner');\n  }\n  res.sendFile(path.join(__dirname, 'views', 'login.html'));\n});\n\n// 학습 플래너 페이지\napp.get('/planner', (req, res) => {\n  if (!req.session.studentId) {\n    return res.redirect('/');\n  }\n  res.sendFile(path.join(__dirname, 'views', 'planner.html'));\n});\n\n// 세션에서 학생 정보 가져오기 API\napp.get('/api/student-info', (req, res) => {\n  if (!req.session.studentId) {\n    return res.status(401).json({ error: '로그인이 필요합니다' });\n  }\n  \n  res.json({\n    studentId: req.session.studentId,\n    studentName: req.session.studentName || req.session.studentId,\n    studentRealName: req.session.studentRealName || req.session.studentName || req.session.studentId\n  });\n});\n\n// 선생님 페이지\n// 선생님 로그인 페이지\napp.get('/teacher-login', (req, res) => {\n  res.sendFile(path.join(__dirname, 'views', 'teacher-login.html'));\n});\n\n// 다중 사용자 계정 설정\nconst userAccounts = {\n  // 매니저 (전체 관리)\n  'manager': { password: 'rdtd112!@', role: 'manager', name: '매니저', assignedStudents: 'all' },\n  \n  // 선생님 4명 (담당 학생만)\n  'teacher1': { password: 'rdtd112!@', role: 'teacher', name: '선생님1', assignedStudents: [] },\n  'teacher2': { password: 'rdtd112!@', role: 'teacher', name: '선생님2', assignedStudents: [] },\n  'teacher3': { password: 'rdtd112!@', role: 'teacher', name: '선생님3', assignedStudents: [] },\n  'teacher4': { password: 'rdtd112!@', role: 'teacher', name: '선생님4', assignedStudents: [] },\n  \n  // 아르바이트생 2명 (제한적 권한)\n  'assistant1': { password: 'rdtd112!@', role: 'assistant', name: '아르바이트1', assignedStudents: [] },\n  'assistant2': { password: 'rdtd112!@', role: 'assistant', name: '아르바이트2', assignedStudents: [] }\n};\n\n// 선생님 로그인 처리\napp.post('/teacher-login', async (req, res) => {\n  const { teacherId, teacherPassword } = req.body;\n  \n  // 사용자 계정 확인\n  const userAccount = userAccounts[teacherId];\n  \n  if (userAccount && teacherPassword === userAccount.password) {\n    // 보안: 세션 고정 공격 방지를 위한 세션 ID 재생성\n    req.session.regenerate((err) => {\n      if (err) {\n        console.error('세션 재생성 오류:', err);\n        return res.json({ success: false, message: '로그인 처리 중 오류가 발생했습니다.' });\n      }\n      \n      // 세션에 사용자 정보 저장\n      req.session.isTeacher = true;\n      req.session.userId = teacherId;\n      req.session.userRole = userAccount.role;\n      req.session.userName = userAccount.name;\n      req.session.assignedStudents = userAccount.assignedStudents;\n      \n      console.log(`로그인 성공: ${userAccount.name} (${userAccount.role})`);\n      \n      // 세션 저장 후 응답\n      req.session.save((err) => {\n        if (err) {\n          console.error('세션 저장 오류:', err);\n          return res.json({ success: false, message: '로그인 처리 중 오류가 발생했습니다.' });\n        }\n        res.json({ success: true, message: '로그인 성공' });\n      });\n    });\n  } else {\n    console.log(`로그인 실패: ${teacherId}`);\n    res.json({ success: false, message: '아이디 또는 비밀번호가 올바르지 않습니다.' });\n  }\n});\n\n// 선생님 로그아웃\napp.post('/teacher-logout', (req, res) => {\n  // 보안: 완전한 세션 파기 및 쿠키 삭제\n  req.session.destroy((err) => {\n    if (err) {\n      console.error('세션 파기 오류:', err);\n      return res.json({ success: false, message: '로그아웃 처리 중 오류가 발생했습니다.' });\n    }\n    \n    // 세션 쿠키 삭제\n    res.clearCookie('connect.sid'); // 기본 세션 쿠키 이름\n    res.json({ success: true, message: '로그아웃 되었습니다.' });\n  });\n});\n\n// 선생님 대시보드 (세션 확인 필요)\napp.get('/teacher', (req, res) => {\n  if (!req.session.isTeacher) {\n    return res.redirect('/teacher-login');\n  }\n  res.sendFile(path.join(__dirname, 'views', 'teacher.html'));\n});\n\n// 로그인 처리\napp.post('/login', async (req, res) => {\n  const { studentId, password } = req.body;\n  \n  try {\n    // 학생 정보 조회 - REST API 직접 호출\n    const accessToken = await getAccessToken();\n    \n    const restResponse = await fetch(`https://api.notion.com/v1/databases/${STUDENT_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          and: [\n            {\n              property: '학생 ID',\n              rich_text: {\n                equals: studentId\n              }\n            },\n            {\n              property: '비밀번호',\n              rich_text: {\n                equals: password.toString()\n              }\n            }\n          ]\n        }\n      })\n    });\n    \n    if (!restResponse.ok) {\n      const errorText = await restResponse.text();\n      console.error('로그인 API 오류:', errorText);\n      throw new Error(`로그인 API 호출 실패: ${restResponse.status}`);\n    }\n    \n    const response = await restResponse.json();\n\n    if (response.results.length > 0) {\n      req.session.studentId = studentId;\n      \n      // 학생 데이터베이스의 모든 필드 확인 (디버깅용)\n      console.log('학생 데이터베이스 필드들:', Object.keys(response.results[0].properties));\n      \n      // 실제 이름 필드 찾기 ('이름', 'Name', '학생이름' 등 시도)\n      const studentRecord = response.results[0].properties;\n      let realName = null;\n      \n      // 가능한 이름 필드들 시도\n      const nameFields = ['이름', 'Name', '학생이름', '학생 이름', '성명'];\n      for (const field of nameFields) {\n        if (studentRecord[field]?.rich_text?.[0]?.plain_text) {\n          realName = studentRecord[field].rich_text[0].plain_text;\n          console.log(`찾은 이름 필드: ${field} = ${realName}`);\n          break;\n        }\n        if (studentRecord[field]?.title?.[0]?.plain_text) {\n          realName = studentRecord[field].title[0].plain_text;\n          console.log(`찾은 이름 필드 (title): ${field} = ${realName}`);\n          break;\n        }\n      }\n      \n      req.session.studentName = realName || studentId;\n      req.session.studentRealName = realName; // 실제 이름 별도 저장\n      console.log('세션에 저장된 학생 이름:', req.session.studentName);\n      \n      res.json({ success: true, message: '로그인 성공!' });\n    } else {\n      res.json({ success: false, message: '아이디 또는 비밀번호가 올바르지 않습니다.' });\n    }\n  } catch (error) {\n    console.error('로그인 오류:', error);\n    res.json({ success: false, message: '로그인 중 오류가 발생했습니다.' });\n  }\n});\n\n// 로그아웃\napp.post('/logout', (req, res) => {\n  req.session.destroy();\n  res.redirect('/');\n});\n\n// 학습 데이터 저장\napp.post('/save-progress', async (req, res) => {\n  console.log('=== 저장 요청 시작 ===');\n  console.log('세션 학생 ID:', req.session.studentId);\n  console.log('받은 폼 데이터:', JSON.stringify(req.body, null, 2));\n  \n  if (!req.session.studentId) {\n    return res.json({ success: false, message: '로그인이 필요합니다.' });\n  }\n\n  try {\n    console.log('액세스 토큰 획득 중...');\n    const accessToken = await getAccessToken();\n    console.log('액세스 토큰 획득 완료');\n    \n    const formData = req.body;\n    \n    // 오늘 날짜로 새 항목 생성\n    const today = new Date().toISOString().split('T')[0];\n    \n    // 학생 정보부터 찾기 - relation 필드를 위해 학생의 실제 페이지 ID 필요\n    console.log('학생 페이지 ID 찾는 중... 학생 ID:', req.session.studentId);\n    \n    // REST API로 학생 데이터베이스에서 이 학생의 페이지 ID 찾기\n    const studentResponse = await fetch(`https://api.notion.com/v1/databases/${STUDENT_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          property: '학생 ID',\n          rich_text: {\n            equals: req.session.studentId\n          }\n        }\n      })\n    });\n    \n    if (!studentResponse.ok) {\n      throw new Error(`학생 정보 조회 실패: ${studentResponse.status}`);\n    }\n    \n    const studentData = await studentResponse.json();\n    \n    if (studentData.results.length === 0) {\n      throw new Error(`학생 ID ${req.session.studentId}를 찾을 수 없습니다.`);\n    }\n    \n    const studentPageId = studentData.results[0].id;\n    console.log('찾은 학생 페이지 ID:', studentPageId);\n    \n    // 오늘 날짜에 해당하는 기존 일지 찾기 (MAKE가 아침에 생성한 껍데기 일지)\n    console.log('오늘 날짜의 기존 일지 찾는 중...');\n    const existingLogResponse = await fetch(`https://api.notion.com/v1/databases/${PROGRESS_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          and: [\n            {\n              property: '🕐 날짜',\n              date: {\n                equals: today\n              }\n            },\n            {\n              property: '학생 명부 관리',\n              relation: {\n                contains: studentPageId\n              }\n            }\n          ]\n        }\n      })\n    });\n    \n    if (!existingLogResponse.ok) {\n      throw new Error(`기존 일지 조회 실패: ${existingLogResponse.status}`);\n    }\n    \n    const existingLogData = await existingLogResponse.json();\n    \n    if (existingLogData.results.length === 0) {\n      throw new Error(`오늘 날짜(${today})의 기존 일지를 찾을 수 없습니다. MAKE 자동화가 실행되었는지 확인해주세요.`);\n    }\n    \n    const existingPageId = existingLogData.results[0].id;\n    console.log('찾은 기존 일지 페이지 ID:', existingPageId);\n    \n    // 업데이트할 properties (날짜와 학생 관계는 이미 설정되어 있으므로 제외)\n    const properties = {};\n\n    // 숙제 확인 필드들 (상태 속성) - \"해당없음\"은 저장하지 않음\n    if (formData['⭕ 지난 문법 숙제 검사'] && formData['⭕ 지난 문법 숙제 검사'] !== '해당없음') {\n      properties['⭕ 지난 문법 숙제 검사'] = { status: { name: formData['⭕ 지난 문법 숙제 검사'] } };\n    }\n    if (formData['1️⃣ 어휘 클카 암기 숙제'] && formData['1️⃣ 어휘 클카 암기 숙제'] !== '해당없음') {\n      properties['1️⃣ 어휘 클카 암기 숙제'] = { status: { name: formData['1️⃣ 어휘 클카 암기 숙제'] } };\n    }\n    if (formData['2️⃣ 독해 단어 클카 숙제'] && formData['2️⃣ 독해 단어 클카 숙제'] !== '해당없음') {\n      properties['2️⃣ 독해 단어 클카 숙제'] = { status: { name: formData['2️⃣ 독해 단어 클카 숙제'] } };\n    }\n    if (formData['4️⃣ Summary 숙제'] && formData['4️⃣ Summary 숙제'] !== '해당없음') {\n      properties['4️⃣ Summary 숙제'] = { status: { name: formData['4️⃣ Summary 숙제'] } };\n    }\n    if (formData['5️⃣ 매일 독해 숙제'] && formData['5️⃣ 매일 독해 숙제'] !== '해당없음') {\n      properties['5️⃣ 매일 독해 숙제'] = { status: { name: formData['5️⃣ 매일 독해 숙제'] } };\n    }\n    if (formData['6️⃣ 영어 일기(초등) / 개인 독해서 (중고등)'] && formData['6️⃣ 영어 일기(초등) / 개인 독해서 (중고등)'] !== '해당없음') {\n      properties['6️⃣ 영어 일기(초등) / 개인 독해서 (중고등)'] = { status: { name: formData['6️⃣ 영어 일기(초등) / 개인 독해서 (중고등)'] } };\n    }\n\n    // 폼 데이터를 Notion 속성으로 변환\n    if (formData['어휘정답']) {\n      properties['어휘정답'] = { number: parseInt(formData['어휘정답']) || 0 };\n    }\n    if (formData['어휘총문제']) {\n      properties['어휘총문제'] = { number: parseInt(formData['어휘총문제']) || 0 };\n    }\n    if (formData['어휘유닛']) {\n      properties['어휘유닛'] = { rich_text: [{ text: { content: formData['어휘유닛'] } }] };\n    }\n    if (formData['문법 전체 개수']) {\n      properties['문법 전체 개수'] = { number: parseInt(formData['문법 전체 개수']) || 0 };\n    }\n    if (formData['문법숙제오답']) {\n      properties['문법숙제오답'] = { number: parseInt(formData['문법숙제오답']) || 0 };\n    }\n    if (formData['독해오답갯수']) {\n      properties['독해오답갯수'] = { number: parseInt(formData['독해오답갯수']) || 0 };\n    }\n    if (formData['독해하브루타']) {\n      properties['독해하브'] = { select: { name: formData['독해하브루타'] } };\n    }\n    if (formData['영어 더빙 학습 완료']) {\n      properties['영어 더빙 학습 완료'] = { status: { name: formData['영어 더빙 학습 완료'] } };\n    }\n    if (formData['더빙 워크북 완료']) {\n      properties['더빙 워크북 완료'] = { status: { name: formData['더빙 워크북 완료'] } };\n    }\n    if (formData['📖 영어독서']) {\n      properties['📖 영어독서'] = { select: { name: formData['📖 영어독서'] } };\n    }\n    if (formData['어휘학습']) {\n      properties['어휘학습'] = { select: { name: formData['어휘학습'] } };\n    }\n    if (formData['Writing']) {\n      properties['Writing'] = { select: { name: formData['Writing'] } };\n    }\n    // 영어 책 relation 연결 (오늘 읽은 영어 책)\n    if (formData['오늘 읽은 영어 책']) {\n      console.log('영어 책 검색 중:', formData['오늘 읽은 영어 책']);\n      \n      // 영어 책 데이터베이스에서 해당 책 찾기\n      const englishBookResponse = await fetch(`https://api.notion.com/v1/databases/${BOOK_LIST_DB_ID}/query`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'Notion-Version': '2022-06-28'\n        },\n        body: JSON.stringify({\n          filter: {\n            property: 'Title',\n            title: {\n              equals: formData['오늘 읽은 영어 책']\n            }\n          }\n        })\n      });\n      \n      if (englishBookResponse.ok) {\n        const englishBookData = await englishBookResponse.json();\n        if (englishBookData.results.length > 0) {\n          const bookPageId = englishBookData.results[0].id;\n          console.log('찾은 영어 책 페이지 ID:', bookPageId);\n          properties['오늘 읽은 영어 책'] = { relation: [{ id: bookPageId }] };\n        } else {\n          console.log('영어 책을 찾을 수 없음:', formData['오늘 읽은 영어 책']);\n        }\n      }\n    }\n    \n    // 3독 독서 제목 relation 연결\n    if (formData['3독 독서 제목']) {\n      console.log('3독 독서 책 검색 중:', formData['3독 독서 제목']);\n      \n      // 사유독평 책 데이터베이스에서 해당 책 찾기\n      const sayuBookResponse = await fetch(`https://api.notion.com/v1/databases/${SAYU_BOOK_DB_ID}/query`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'Notion-Version': '2022-06-28'\n        },\n        body: JSON.stringify({\n          filter: {\n            property: '3독 요약 사유독평 도서 보유 목록',\n            title: {\n              equals: formData['3독 독서 제목']\n            }\n          }\n        })\n      });\n      \n      if (sayuBookResponse.ok) {\n        const sayuBookData = await sayuBookResponse.json();\n        if (sayuBookData.results.length > 0) {\n          const bookPageId = sayuBookData.results[0].id;\n          console.log('찾은 3독 독서 책 페이지 ID:', bookPageId);\n          properties['3독 독서 제목'] = { relation: [{ id: bookPageId }] };\n        } else {\n          console.log('3독 독서 책을 찾을 수 없음:', formData['3독 독서 제목']);\n        }\n      }\n    }\n    \n    if (formData['📕 책 읽는 거인']) {\n      properties['📕 책 읽는 거인'] = { select: { name: formData['📕 책 읽는 거인'] } };\n    }\n    if (formData['오늘의 학습 소감']) {\n      properties['오늘의 학습 소감'] = { rich_text: [{ text: { content: formData['오늘의 학습 소감'] } }] };\n    }\n\n    console.log('최종 업데이트 properties 객체:', JSON.stringify(properties, null, 2));\n    console.log('업데이트할 기존 일지 ID:', existingPageId);\n    \n    // REST API로 기존 Notion 페이지 업데이트\n    console.log('Notion 페이지 업데이트 API 호출 중...');\n    const updateResponse = await fetch(`https://api.notion.com/v1/pages/${existingPageId}`, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        properties: properties\n      })\n    });\n    \n    if (!updateResponse.ok) {\n      const errorText = await updateResponse.text();\n      console.error('페이지 업데이트 실패 상세:', errorText);\n      throw new Error(`페이지 업데이트 실패: ${updateResponse.status} - ${errorText}`);\n    }\n    \n    const result = await updateResponse.json();\n    console.log('업데이트 성공! 기존 일지 ID:', result.id);\n    res.json({ success: true, message: '학습 데이터가 성공적으로 저장되었습니다!' });\n  } catch (error) {\n    console.error('=== 저장 오류 발생 ===');\n    console.error('오류 메시지:', error.message);\n    console.error('오류 스택:', error.stack);\n    if (error.body) {\n      console.error('Notion API 오류 상세:', JSON.stringify(error.body, null, 2));\n    }\n    res.json({ success: false, message: '저장 중 오류가 발생했습니다: ' + error.message });\n  }\n});\n\n// 선생님 API 인증 미들웨어 (세션 기반만 허용)\nfunction requireTeacherAuth(req, res, next) {\n  // 세션 확인\n  if (req.session && req.session.isTeacher) {\n    return next();\n  }\n  \n  // 보안: 프로덕션에서는 세션 기반 인증만 허용\n  // 개발 환경에서만 토큰 기반 허용 (보안 강화)\n  if (process.env.NODE_ENV !== 'production') {\n    const authHeader = req.headers.authorization;\n    const validToken = process.env.TEACHER_ACCESS_TOKEN;\n    \n    if (validToken && authHeader === `Bearer ${validToken}`) {\n      return next();\n    }\n  }\n  \n  return res.status(401).json({ \n    error: '선생님 인증이 필요합니다. 로그인해주세요.',\n    redirect: '/teacher-login'\n  });\n}\n\n// 전체 학생 진도 조회 (선생님용)\napp.get('/api/student-progress', requireTeacherAuth, async (req, res) => {\n  try {\n    console.log('선생님 진도 조회 시작...');\n    const notion = await getUncachableNotionClient();\n    console.log('Notion 클라이언트 타입:', typeof notion, notion && notion.constructor && notion.constructor.name);\n    \n    // Notion 클라이언트가 제대로 생성되었는지 확인\n    if (!notion || typeof notion.databases?.query !== 'function') {\n      console.error('Notion 클라이언트가 올바르지 않음:', notion);\n      // 임시 데이터 반환하여 대시보드 테스트 가능하게 함\n      return res.json([\n        {\n          id: 'temp1',\n          studentId: 'Test 원장',\n          date: '2025-09-24',\n          vocabScore: 85,\n          grammarScore: 90,\n          readingResult: 'pass',\n          englishReading: '완료함',\n          bookTitle: 'Harry Potter',\n          feeling: '오늘 영어 공부가 재미있었어요!'\n        },\n        {\n          id: 'temp2',\n          studentId: 'Test 원장',\n          date: '2025-09-23',\n          vocabScore: 78,\n          grammarScore: 82,\n          readingResult: 'pass',\n          englishReading: '완료함',\n          bookTitle: 'Charlotte\\'s Web',\n          feeling: '단어가 조금 어려웠지만 열심히 했어요.'\n        }\n      ]);\n    }\n\n    const response = await notion.databases.query({\n      database_id: PROGRESS_DB_ID,\n      sorts: [\n        {\n          property: '날짜',\n          direction: 'descending'\n        }\n      ]\n    });\n\n    const progressData = response.results.map(page => {\n      const props = page.properties;\n      return {\n        id: page.id,\n        studentId: props['학생 ID']?.rich_text?.[0]?.plain_text || '',\n        date: props['날짜']?.date?.start || '',\n        vocabScore: props['📰 단어 테스트 점수']?.formula?.number || 0,\n        grammarScore: props['📑 문법 시험 점수']?.formula?.number || 0,\n        readingResult: props['📚 독해 해석 시험 결과']?.formula?.string || '',\n        englishReading: props['📖 영어독서']?.select?.name || '',\n        bookTitle: props['오늘 읽은 영어 책']?.rich_text?.[0]?.plain_text || '',\n        feeling: props['오늘의 학습 소감']?.rich_text?.[0]?.plain_text || ''\n      };\n    });\n\n    // 권한별 데이터 필터링\n    const filteredData = filterStudentsByRole(userRole, assignedStudents, progressData);\n    \n    // 활동 로그 기록\n    console.log(`${userName}(${userRole})이 ${filteredData.length}건의 진도 데이터를 조회했습니다.`);\n    \n    res.json(filteredData);\n  } catch (error) {\n    console.error('전체 진도 조회 오류:', error);\n    // 에러 발생시에도 권한별 임시 데이터 반환\n    const errorSampleData = [\n      {\n        id: 'temp1',\n        studentId: 'Test 원장',\n        date: '2025-09-25',\n        vocabScore: 85,\n        grammarScore: 90,\n        readingResult: 'pass',\n        englishReading: '완료함',\n        bookTitle: 'Harry Potter',\n        feeling: '오늘 영어 공부가 재미있었어요!',\n        assignedTeacher: '선생님1'\n      }\n    ];\n    res.json(filterStudentsByRole(userRole, assignedStudents, errorSampleData));\n  }\n});\n\n// 특정 학생 진도 조회 (선생님용)\napp.get('/api/student-progress/:studentId', requireTeacherAuth, async (req, res) => {\n  try {\n    const notion = await getUncachableNotionClient();\n    const { studentId } = req.params;\n    \n    const response = await notion.databases.query({\n      database_id: PROGRESS_DB_ID,\n      filter: {\n        property: '학생 ID',\n        rich_text: {\n          equals: studentId\n        }\n      },\n      sorts: [\n        {\n          property: '날짜',\n          direction: 'descending'\n        }\n      ]\n    });\n\n    const progressData = response.results.map(page => {\n      const props = page.properties;\n      return {\n        id: page.id,\n        studentId: props['학생 ID']?.rich_text?.[0]?.plain_text || '',\n        date: props['날짜']?.date?.start || '',\n        vocabScore: props['📰 단어 테스트 점수']?.formula?.number || 0,\n        grammarScore: props['📑 문법 시험 점수']?.formula?.number || 0,\n        readingResult: props['📚 독해 해석 시험 결과']?.formula?.string || '',\n        englishReading: props['📖 영어독서']?.select?.name || '',\n        bookTitle: props['오늘 읽은 영어 책']?.rich_text?.[0]?.plain_text || '',\n        feeling: props['오늘의 학습 소감']?.rich_text?.[0]?.plain_text || ''\n      };\n    });\n\n    res.json(progressData);\n  } catch (error) {\n    console.error('특정 학생 진도 조회 오류:', error);\n    res.json({ error: '진도 조회 중 오류가 발생했습니다.' });\n  }\n});\n\n// 서버 시작\napp.listen(PORT, '0.0.0.0', async () => {\n  console.log(`🚀 학습 플래너 서버가 포트 ${PORT}에서 실행 중입니다!`);\n  console.log(`📝 학생용: http://localhost:${PORT}`);\n  console.log(`👩‍🏫 선생님용: http://localhost:${PORT}/teacher`);\n  \n  // Notion 연결 상태 확인\n  try {\n    console.log('🔗 Notion 연결 상태를 확인중...');\n    const notion = await getUncachableNotionClient();\n    console.log('✅ Notion 연결 성공!');\n    \n  } catch (error) {\n    console.error('❌ Notion 연결 실패:', error.message);\n    console.log('💡 해결 방법: Replit의 Secrets에서 Notion 연결을 확인해주세요');\n  }\n});","size_bytes":32487},"api/index.js":{"content":"import express from 'express';\nimport cors from 'cors';\nimport bodyParser from 'body-parser';\nimport jwt from 'jsonwebtoken';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { getUncachableNotionClient } from '../notion-client.js';\nimport { Client } from '@notionhq/client';\n\n// JWT 시크릿 키 (프로덕션에서 필수)\nconst JWT_SECRET = process.env.JWT_SECRET;\nconst DEV_SECRET = 'dev-only-secret-readitude-2025'; // 고정된 개발용 시크릿\n\nif (!JWT_SECRET) {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error('JWT_SECRET environment variable is required in production');\n  }\n  console.warn('⚠️ 개발 환경: JWT_SECRET이 설정되지 않음. 고정된 개발용 시크릿 사용.');\n}\n\n// 기존에 잘 작동하던 getAccessToken 함수\nasync function getAccessToken() {\n  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME\n  const xReplitToken = process.env.REPL_IDENTITY \n    ? 'repl ' + process.env.REPL_IDENTITY \n    : process.env.WEB_REPL_RENEWAL \n    ? 'depl ' + process.env.WEB_REPL_RENEWAL \n    : null;\n\n  if (!xReplitToken) {\n    throw new Error('X_REPLIT_TOKEN not found for repl/depl');\n  }\n\n  const connectionSettings = await fetch(\n    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=notion',\n    {\n      headers: {\n        'Accept': 'application/json',\n        'X_REPLIT_TOKEN': xReplitToken\n      }\n    }\n  ).then(res => res.json()).then(data => data.items?.[0]);\n\n  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token;\n\n  if (!connectionSettings || !accessToken) {\n    throw new Error('Notion not connected');\n  }\n  return accessToken;\n}\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst app = express();\nconst PORT = process.env.PORT || 5000;\n\n// 다중 사용자 계정 설정 (환경변수로 관리 예정)\nconst userAccounts = {\n  // 매니저 (전체 관리)\n  'manager': { password: 'rdtd112!@', role: 'manager', name: '매니저', assignedStudents: 'all' },\n  \n  // 선생님 4명 (담당 학생만)\n  'teacher1': { password: 'rdtd112!@', role: 'teacher', name: '선생님1', assignedStudents: [] },\n  'teacher2': { password: 'rdtd112!@', role: 'teacher', name: '선생님2', assignedStudents: [] },\n  'teacher3': { password: 'rdtd112!@', role: 'teacher', name: '선생님3', assignedStudents: [] },\n  'teacher4': { password: 'rdtd112!@', role: 'teacher', name: '선생님4', assignedStudents: [] },\n  \n  // 아르바이트생 2명 (제한적 권한)\n  'assistant1': { password: 'rdtd112!@', role: 'assistant', name: '아르바이트1', assignedStudents: [] },\n  'assistant2': { password: 'rdtd112!@', role: 'assistant', name: '아르바이트2', assignedStudents: [] }\n};\n\n// JWT 토큰 생성 함수 (학생/선생님 공용)\nfunction generateToken(userData) {\n  const secret = JWT_SECRET || DEV_SECRET;\n  const tokenPayload = {\n    userId: userData.loginId,\n    role: userData.role,\n    name: userData.name\n  };\n  \n  // 학생의 경우 realName 포함\n  if (userData.realName) {\n    tokenPayload.realName = userData.realName;\n  }\n  \n  return jwt.sign(tokenPayload, secret, { expiresIn: '24h' });\n}\n\n// JWT 토큰 검증 함수\nfunction verifyToken(token) {\n  try {\n    const secret = JWT_SECRET || DEV_SECRET;\n    return jwt.verify(token, secret);\n  } catch (error) {\n    return null;\n  }\n}\n\n// 미들웨어 설정\napp.use(cors({\n  origin: process.env.NODE_ENV === 'production' \n    ? ['https://vercel.app', 'https://*.vercel.app'] \n    : ['http://localhost:3000', 'http://localhost:5000'],\n  credentials: true\n}));\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: true }));\n\n// 정적 파일 서빙 (Vercel용)\napp.use(express.static(path.join(__dirname, '../public')));\n\n// JWT 기반 사용자 인증 미들웨어\nfunction requireAuth(req, res, next) {\n  const token = req.headers.authorization?.replace('Bearer ', '') || req.cookies?.auth_token;\n  \n  if (!token) {\n    return res.status(401).json({ error: '인증 토큰이 필요합니다' });\n  }\n  \n  const decoded = verifyToken(token);\n  if (!decoded) {\n    return res.status(401).json({ error: '유효하지 않은 토큰입니다' });\n  }\n  \n  req.user = decoded;\n  next();\n}\n\n// 권한별 데이터 필터링 함수\nfunction filterStudentsByRole(userRole, userName, assignedStudents, data) {\n  if (userRole === 'manager') {\n    return data; // 매니저는 모든 데이터 접근\n  } else if (userRole === 'teacher') {\n    // 선생님은 담당 학생만 (현재는 임시로 모든 데이터)\n    return data;\n  } else if (userRole === 'assistant') {\n    // 아르바이트는 제한된 데이터 (최근 15건)\n    return data.slice(0, 15);\n  }\n  return [];\n}\n\n// 날짜별 데이터 필터링 함수\nfunction filterDataByDate(data, period, startDate, endDate) {\n  if (!period || period === 'all') return data;\n  \n  const now = new Date();\n  let filterDate;\n  \n  if (period === 'today') {\n    filterDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    return data.filter(item => new Date(item.date) >= filterDate);\n  } else if (period === 'week') {\n    filterDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    return data.filter(item => new Date(item.date) >= filterDate);\n  } else if (period === 'month') {\n    filterDate = new Date(now.getFullYear(), now.getMonth(), 1);\n    return data.filter(item => new Date(item.date) >= filterDate);\n  } else if (period === 'custom' && startDate && endDate) {\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    return data.filter(item => {\n      const itemDate = new Date(item.date);\n      return itemDate >= start && itemDate <= end;\n    });\n  }\n  \n  return data;\n}\n\n// 메인 페이지 (학생 로그인)\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, '../public/views/login.html'));\n});\n\n// Vercel 호환 학생 로그인 처리\napp.post('/login', async (req, res) => {\n  const { studentId, studentPassword } = req.body;\n  \n  console.log('학생 로그인 시도:', { studentId, password: '***' });\n  \n  try {\n    // Vercel 호환: 직접 NOTION_ACCESS_TOKEN 사용 또는 Replit 커넥터 폴백\n    let accessToken;\n    \n    if (process.env.NOTION_ACCESS_TOKEN) {\n      // Vercel 배포용: 직접 토큰 사용\n      accessToken = process.env.NOTION_ACCESS_TOKEN;\n      console.log('Vercel 모드: NOTION_ACCESS_TOKEN 사용');\n    } else {\n      // Replit 개발용: 커넥터 사용\n      accessToken = await getAccessToken();\n      console.log('Replit 모드: 커넥터 사용');\n    }\n    \n    // 정확한 \"New 학생 명부 관리\" 데이터베이스 ID 사용\n    const STUDENT_DB_ID = '25409320-bce2-80f8-ace1-ddcdd022b360';\n    \n    if (!STUDENT_DB_ID) {\n      console.error('학생 데이터베이스 ID가 설정되지 않았습니다');\n      return res.json({ success: false, message: '데이터베이스 설정 오류. 관리자에게 문의하세요.' });\n    }\n    \n    console.log('학생 DB ID:', STUDENT_DB_ID);\n    \n    // 먼저 데이터베이스 스키마 확인\n    const schemaResponse = await fetch(`https://api.notion.com/v1/databases/${STUDENT_DB_ID}`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      }\n    });\n    \n    if (schemaResponse.ok) {\n      const schema = await schemaResponse.json();\n      console.log('데이터베이스 속성들:', Object.keys(schema.properties));\n    }\n    \n    // 정확한 데이터베이스와 속성명으로 로그인 처리\n    const restResponse = await fetch(`https://api.notion.com/v1/databases/${STUDENT_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: {\n          and: [\n            {\n              property: '학생 ID',\n              rich_text: {\n                equals: studentId\n              }\n            },\n            {\n              property: '비밀번호',\n              rich_text: {\n                equals: studentPassword.toString()\n              }\n            }\n          ]\n        }\n      })\n    });\n    \n    if (!restResponse.ok) {\n      const errorText = await restResponse.text();\n      console.error('로그인 API 오류:', errorText);\n      throw new Error(`로그인 API 호출 실패: ${restResponse.status}`);\n    }\n    \n    const response = await restResponse.json();\n    console.log('노션 응답 길이:', response.results.length);\n\n    if (response.results.length > 0) {\n      // 학생 데이터베이스의 모든 필드 확인 (디버깅용)\n      console.log('학생 데이터베이스 필드들:', Object.keys(response.results[0].properties));\n      \n      // 실제 이름 필드 찾기 ('이름', 'Name', '학생이름' 등 시도)\n      const studentRecord = response.results[0].properties;\n      let realName = null;\n      \n      // 가능한 이름 필드들 시도\n      const nameFields = ['이름', 'Name', '학생이름', '학생 이름', '성명'];\n      for (const field of nameFields) {\n        if (studentRecord[field]?.rich_text?.[0]?.plain_text) {\n          realName = studentRecord[field].rich_text[0].plain_text;\n          console.log(`찾은 이름 필드: ${field} = ${realName}`);\n          break;\n        }\n        if (studentRecord[field]?.title?.[0]?.plain_text) {\n          realName = studentRecord[field].title[0].plain_text;\n          console.log(`찾은 이름 필드 (title): ${field} = ${realName}`);\n          break;\n        }\n      }\n      \n      const studentName = realName || studentId;\n      const studentRealName = realName || studentId;\n      \n      // JWT 토큰 생성\n      const token = generateToken({\n        loginId: studentId,\n        role: 'student',\n        name: studentName,\n        realName: studentRealName\n      });\n\n      console.log('로그인 성공:', studentId);\n\n      res.json({ \n        success: true, \n        message: '로그인 성공!',\n        token: token,\n        studentInfo: {\n          studentId: studentId,\n          studentName: studentName,\n          studentRealName: studentRealName\n        }\n      });\n    } else {\n      console.log('아이디 또는 비밀번호 불일치');\n      res.json({ success: false, message: '아이디 또는 비밀번호가 올바르지 않습니다.' });\n    }\n  } catch (error) {\n    console.error('로그인 오류:', error);\n    res.json({ success: false, message: '로그인 중 오류가 발생했습니다.' });\n  }\n});\n\n// 학생 로그아웃\napp.post('/logout', (req, res) => {\n  res.json({ success: true, message: '로그아웃 되었습니다.' });\n});\n\n// 학생 플래너 페이지\napp.get('/planner', (req, res) => {\n  res.sendFile(path.join(__dirname, '../public/views/planner.html'));\n});\n\n// 학생 정보 API (JWT 기반)\napp.get('/api/student-info', (req, res) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  const decoded = verifyToken(token);\n  \n  if (!decoded || decoded.role !== 'student') {\n    return res.status(401).json({ error: '학생 인증이 필요합니다' });\n  }\n  \n  res.json({\n    studentId: decoded.userId,\n    studentName: decoded.name || decoded.userId,\n    studentRealName: decoded.realName || decoded.name || decoded.userId\n  });\n});\n\n// 선생님 로그인 페이지\napp.get('/teacher-login', (req, res) => {\n  res.sendFile(path.join(__dirname, '../public/views/teacher-login.html'));\n});\n\n// 선생님 로그인 처리 (JWT 기반)\napp.post('/teacher-login', async (req, res) => {\n  const { teacherId, teacherPassword } = req.body;\n  \n  // 사용자 계정 확인\n  const userAccount = userAccounts[teacherId];\n  \n  if (userAccount && teacherPassword === userAccount.password) {\n    // JWT 토큰 생성\n    const token = generateToken({\n      loginId: teacherId,\n      name: userAccount.name,\n      role: userAccount.role\n    });\n    \n    console.log(`로그인 성공: ${userAccount.name} (${userAccount.role})`);\n    \n    res.json({ \n      success: true, \n      message: '로그인 성공',\n      token: token,\n      userInfo: {\n        userId: teacherId,\n        userName: userAccount.name,\n        userRole: userAccount.role\n      }\n    });\n  } else {\n    console.log(`로그인 실패: ${teacherId}`);\n    res.status(401).json({ \n      success: false, \n      message: '아이디 또는 비밀번호가 올바르지 않습니다.' \n    });\n  }\n});\n\n// 선생님 로그아웃 (JWT는 클라이언트에서 토큰 삭제)\napp.post('/teacher-logout', (req, res) => {\n  res.json({ success: true, message: '로그아웃 되었습니다.' });\n});\n\n// 선생님 대시보드\napp.get('/teacher', (req, res) => {\n  res.sendFile(path.join(__dirname, '../public/views/teacher.html'));\n});\n\n// 선생님 대시보드 페이지\napp.get('/teacher-dashboard', (req, res) => {\n  res.sendFile(path.join(__dirname, '../public/views/teacher-dashboard.html'));\n});\n\n// 사용자 정보 조회 API (JWT 기반)\napp.get('/api/user-info', requireAuth, (req, res) => {\n  res.json({\n    userId: req.user.userId,\n    userName: req.user.name,\n    userRole: req.user.role\n  });\n});\n\n// 선생님 대시보드용 사용자 정보 API (별칭)\napp.get('/api/teacher/user-info', requireAuth, (req, res) => {\n  res.json({\n    userId: req.user.userId,\n    userName: req.user.name,\n    userRole: req.user.role\n  });\n});\n\n// 숙제 현황 조회 API (JWT 기반) - Manager는 전체, Teacher는 담당 학생만\n// 숙제 현황 조회 API (진도 관리 DB 직접 사용) - 대폭 개선\napp.get('/api/homework-status', requireAuth, async (req, res) => {\n  console.log(`숙제 현황 조회 시작: ${req.user.name} (${req.user.role})`);\n  \n  try {\n    // Vercel 호환: 직접 NOTION_ACCESS_TOKEN 사용 또는 Replit 커넥터 폴백\n    let accessToken;\n    \n    if (process.env.NOTION_ACCESS_TOKEN) {\n      accessToken = process.env.NOTION_ACCESS_TOKEN;\n      console.log('Vercel 모드: NOTION_ACCESS_TOKEN 사용');\n    } else {\n      accessToken = await getAccessToken();\n      console.log('Replit 모드: 커넥터 사용');\n    }\n    \n    // 쿼리 파라미터 처리\n    const { period, startDate, endDate, teacher } = req.query;\n    console.log(`쿼리 파라미터 확인: period=${period}, teacher=${teacher}`);\n    \n    // 데이터베이스 ID들\n    const STUDENT_DB_ID = '25409320-bce2-80f8-ace1-ddcdd022b360'; // \"New 학생 명부 관리\"\n    const PROGRESS_DB_ID = process.env.PROGRESS_DATABASE_ID || '25409320-bce2-8076-97ed-e3f1c1b62ada'; // \"NEW 리디튜드 학생 진도 관리\"\n    \n    // 날짜 범위 계산\n    let dateFilter = null;\n    const now = new Date();\n    const kstTime = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9\n    \n    if (period === 'today') {\n      const today = kstTime.toISOString().split('T')[0];\n      dateFilter = { date: { equals: today } };\n    } else if (period === 'week') {\n      const weekStart = new Date(kstTime);\n      weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // 이번 주 일요일\n      const weekEnd = new Date(weekStart);\n      weekEnd.setDate(weekStart.getDate() + 6); // 이번 주 토요일\n      dateFilter = {\n        date: {\n          on_or_after: weekStart.toISOString().split('T')[0],\n          on_or_before: weekEnd.toISOString().split('T')[0]\n        }\n      };\n    } else if (period === 'month') {\n      const monthStart = new Date(kstTime.getFullYear(), kstTime.getMonth(), 1);\n      const monthEnd = new Date(kstTime.getFullYear(), kstTime.getMonth() + 1, 0);\n      dateFilter = {\n        date: {\n          on_or_after: monthStart.toISOString().split('T')[0],\n          on_or_before: monthEnd.toISOString().split('T')[0]\n        }\n      };\n    } else if (startDate && endDate) {\n      dateFilter = {\n        date: {\n          on_or_after: startDate,\n          on_or_before: endDate\n        }\n      };\n    } else {\n      // 기본값: 오늘\n      const today = kstTime.toISOString().split('T')[0];\n      dateFilter = { date: { equals: today } };\n    }\n    \n    console.log(`날짜 필터: ${JSON.stringify(dateFilter)}`);\n    console.log(`진도 관리 DB ID: ${PROGRESS_DB_ID}`);\n\n    // Notion API filter 사용하여 최적화된 조회\n    console.log('진도 관리 DB 조회 시작... (Notion API 필터 사용)');\n    const notionFilter = {\n      and: []\n    };\n    \n    // 날짜 필터 추가\n    if (dateFilter) {\n      notionFilter.and.push({\n        property: '🕐 날짜',\n        ...dateFilter\n      });\n    }\n    \n    // 담당강사 필터는 클라이언트측에서 처리 (롤업 필드는 Notion API 필터링이 불안정함)\n    \n    const progressResponse = await fetch(`https://api.notion.com/v1/databases/${PROGRESS_DB_ID}/query`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        filter: notionFilter.and.length > 0 ? notionFilter : undefined,\n        page_size: 100\n      })\n    });\n\n    console.log(`진도 관리 DB 응답 상태: ${progressResponse.status}`);\n    \n    if (!progressResponse.ok) {\n      const errorText = await progressResponse.text();\n      console.error('진도 관리 DB 오류 응답:', errorText);\n      throw new Error(`진도 관리 DB 조회 오류: ${progressResponse.status} - ${errorText}`);\n    }\n\n    const progressData = await progressResponse.json();\n    console.log(`진도 관리에서 조회된 학습일지: ${progressData.results.length}개`);\n    \n    // 데이터베이스 속성들 확인\n    if (progressData.results.length > 0) {\n      const firstPage = progressData.results[0];\n      console.log('진도 관리 DB 속성들:', Object.keys(firstPage.properties));\n    }\n    \n    if (progressData.results.length === 0) {\n      console.log('조건에 맞는 학습일지가 없습니다.');\n      return res.json([]);\n    }\n\n    // 숙제 현황 데이터 추출\n    console.log('진도 관리 DB에서 숙제 상태 직접 추출 시작...');\n    \n    const homeworkData = progressData.results.map(progressPage => {\n      const props = progressPage.properties;\n      const studentName = props['이름']?.title?.[0]?.plain_text || '이름없음';\n      const pageDate = props['🕐 날짜']?.date?.start || '날짜없음';\n      \n      console.log(`=== ${studentName} 학생의 진도 관리 숙제 데이터 (${pageDate}) ===`);\n      \n      // 6가지 숙제 카테고리 상태 확인 (status 속성에서 name 추출)\n      const grammarHomework = props['⭕ 지난 문법 숙제 검사']?.status?.name || '해당없음';\n      const vocabCards = props['1️⃣ 어휘 클카 암기 숙제']?.status?.name || '해당없음';\n      const readingCards = props['2️⃣ 독해 단어 클카 숙제']?.status?.name || '해당없음';\n      const summary = props['4️⃣ Summary 숙제']?.status?.name || '해당없음';\n      const readingHomework = props['5️⃣ 매일 독해 숙제']?.status?.name || '해당없음';\n      const diary = props['6️⃣ 영어 일기(초등) / 개인 독해서 (중고등)']?.status?.name || '해당없음';\n      \n      // 수행율 정보 (formula string에서 추출)\n      const performanceRateString = props['수행율']?.formula?.string || '0%';\n      const performanceRate = parseFloat(performanceRateString.replace('%', '')) || 0;\n      \n      // 담당강사 정보 추출 (rollup)\n      const assignedTeachers = props['담당쌤']?.rollup?.array?.map(item => {\n        if (item.multi_select) {\n          return item.multi_select.map(tag => tag.name);\n        }\n        return [];\n      }).flat() || [];\n      \n      console.log('추출된 값들:');\n      console.log('  ⭕ 지난 문법 숙제 검사:', grammarHomework);\n      console.log('  1️⃣ 어휘 클카:', vocabCards);\n      console.log('  2️⃣ 독해 단어 클카:', readingCards);\n      console.log('  4️⃣ Summary:', summary);\n      console.log('  5️⃣ 매일 독해:', readingHomework);\n      console.log('  6️⃣ 영어 일기:', diary);\n      console.log('  수행율:', performanceRate);\n      console.log('  담당강사 배열:', assignedTeachers);\n      \n      // 완료율 계산 (\"숙제 함\"이면 완료로 간주)\n      const statuses = [grammarHomework, vocabCards, readingCards, summary, readingHomework, diary];\n      const completedCount = statuses.filter(status => status === '숙제 함').length;\n      const completionRate = Math.round((completedCount / 6) * 100);\n      \n      console.log(`완료 체크: ${statuses} -> 완료개수: ${completedCount}/6 = ${completionRate}%`);\n      console.log('===============================');\n      \n      return {\n        pageId: progressPage.id, // Notion 페이지 ID 추가\n        studentId: studentName,\n        date: pageDate,\n        grammarHomework: grammarHomework,\n        vocabCards: vocabCards,\n        readingCards: readingCards,\n        summary: summary,\n        readingHomework: readingHomework,\n        diary: diary,\n        completionRate: performanceRate > 0 ? Math.round(performanceRate) : completionRate,\n        teachers: assignedTeachers,\n        rawData: {\n          name: studentName,\n          date: pageDate,\n          performanceRate: performanceRate,\n          teachers: assignedTeachers\n        }\n      };\n    });\n\n    // 권한 기반 및 담당쌤 필터링\n    let filteredData = homeworkData;\n    \n    // 담당쌤 필터 적용 (매니저가 특정 강사로 필터링할 때)\n    if (teacher && teacher !== 'all') {\n      filteredData = filteredData.filter(student => {\n        return student.teachers && student.teachers.includes(teacher);\n      });\n      console.log(`담당쌤 필터 \"${teacher}\" 적용: ${filteredData.length}명 학생 조회`);\n    }\n    \n    // Teacher 역할인 경우 자신의 담당 학생만 필터링\n    if (req.user.role === 'teacher') {\n      filteredData = filteredData.filter(student => {\n        return student.teachers && student.teachers.includes(req.user.name);\n      });\n      console.log(`Teacher ${req.user.name}: 담당 학생 ${filteredData.length}명 조회`);\n    } else if (req.user.role === 'manager') {\n      console.log(`Manager ${req.user.name}: ${filteredData.length}명 학생 조회`);\n    } else if (req.user.role === 'assistant') {\n      // Assistant: 제한된 데이터\n      filteredData = filteredData.slice(0, 15);\n      console.log(`Assistant ${req.user.name}: 제한된 ${filteredData.length}명 학생 조회`);\n    }\n\n    res.json(filteredData);\n\n  } catch (error) {\n    console.error('숙제 현황 조회 오류:', error);\n    console.error('오류 상세:', error.message);\n    \n    // 오류 시 빈 배열 반환 (샘플 데이터 제거)\n    res.json([]);\n  }\n});\n\n// 강사 목록 API - 학생명부 DB의 담당쌤 속성 옵션 반환\napp.get('/api/teachers', requireAuth, async (req, res) => {\n  console.log(`강사 목록 조회 시작: ${req.user.name} (${req.user.role})`);\n  \n  try {\n    // Vercel 호환: 직접 NOTION_ACCESS_TOKEN 사용 또는 Replit 커넥터 폴백\n    let accessToken;\n    \n    if (process.env.NOTION_ACCESS_TOKEN) {\n      accessToken = process.env.NOTION_ACCESS_TOKEN;\n      console.log('Vercel 모드: NOTION_ACCESS_TOKEN 사용');\n    } else {\n      accessToken = await getAccessToken();\n      console.log('Replit 모드: 커넥터 사용');\n    }\n    \n    const STUDENT_DB_ID = '25409320-bce2-80f8-ace1-ddcdd022b360'; // \"학생 명부 관리\" DB\n    \n    console.log('학생 명부 관리 DB 스키마 조회 중...');\n    const schemaResponse = await fetch(`https://api.notion.com/v1/databases/${STUDENT_DB_ID}`, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      }\n    });\n\n    if (!schemaResponse.ok) {\n      const errorText = await schemaResponse.text();\n      console.error('학생 명부 관리 DB 스키마 조회 오류:', errorText);\n      throw new Error(`학생 명부 관리 DB 스키마 조회 실패: ${schemaResponse.status} - ${errorText}`);\n    }\n\n    const schemaData = await schemaResponse.json();\n    \n    // 담당쌤 속성의 multi_select 옵션들 추출\n    const teachersProperty = schemaData.properties['담당쌤'];\n    \n    if (!teachersProperty || teachersProperty.type !== 'multi_select') {\n      console.error('학생 명부 관리 DB에서 담당쌤 속성을 찾을 수 없거나 multi_select 타입이 아닙니다.');\n      return res.json([]);\n    }\n    \n    const teacherOptions = teachersProperty.multi_select.options.map(option => ({\n      id: option.id,\n      name: option.name,\n      color: option.color\n    }));\n    \n    console.log(`학생 명부 관리 DB에서 담당쌤 옵션 ${teacherOptions.length}개 조회 완료:`, teacherOptions.map(t => t.name));\n    \n    res.json(teacherOptions);\n    \n  } catch (error) {\n    console.error('강사 목록 조회 오류:', error);\n    console.error('오류 상세:', error.message);\n    \n    res.json([]);\n  }\n});\n\n// 숙제 상태 업데이트 API\napp.post('/api/update-homework', requireAuth, async (req, res) => {\n  console.log('숙제 업데이트 요청:', req.user.name, req.body);\n  \n  try {\n    const { pageId, propertyName, newValue } = req.body;\n    \n    // 입력값 검증\n    if (!pageId || !propertyName || newValue === undefined || newValue === null) {\n      return res.status(400).json({ \n        success: false, \n        message: '필수 데이터가 누락되었습니다. (pageId, propertyName, newValue)' \n      });\n    }\n    \n    // Notion 액세스 토큰 가져오기\n    let accessToken;\n    \n    if (process.env.NOTION_ACCESS_TOKEN) {\n      // Vercel 배포용: 직접 토큰 사용\n      accessToken = process.env.NOTION_ACCESS_TOKEN;\n      console.log('Vercel 모드: NOTION_ACCESS_TOKEN 사용');\n    } else {\n      // Replit 개발용: 커넥터 사용\n      accessToken = await getAccessToken();\n      console.log('Replit 모드: 커넥터 사용');\n    }\n    \n    console.log(`Notion 페이지 업데이트 시작: ${pageId}, 속성: ${propertyName}, 값: ${newValue}`);\n    \n    // 먼저 select 타입으로 시도\n    let updateResponse = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': `Bearer ${accessToken}`,\n        'Content-Type': 'application/json',\n        'Notion-Version': '2022-06-28'\n      },\n      body: JSON.stringify({\n        properties: {\n          [propertyName]: {\n            select: {\n              name: newValue\n            }\n          }\n        }\n      })\n    });\n    \n    // select가 실패하면 status 타입으로 재시도\n    if (!updateResponse.ok) {\n      console.log('select 타입 실패, status 타입으로 재시도...');\n      updateResponse = await fetch(`https://api.notion.com/v1/pages/${pageId}`, {\n        method: 'PATCH',\n        headers: {\n          'Authorization': `Bearer ${accessToken}`,\n          'Content-Type': 'application/json',\n          'Notion-Version': '2022-06-28'\n        },\n        body: JSON.stringify({\n          properties: {\n            [propertyName]: {\n              status: {\n                name: newValue\n              }\n            }\n          }\n        }\n      });\n    }\n    \n    if (!updateResponse.ok) {\n      const errorData = await updateResponse.text();\n      console.error('Notion API 업데이트 실패:', updateResponse.status, errorData);\n      \n      let errorMessage = '업데이트에 실패했습니다.';\n      try {\n        const errorJson = JSON.parse(errorData);\n        if (errorJson.message) {\n          errorMessage = errorJson.message;\n        }\n      } catch (e) {\n        // JSON 파싱 실패시 기본 메시지 사용\n      }\n      \n      return res.status(500).json({ \n        success: false, \n        message: errorMessage,\n        details: errorData\n      });\n    }\n    \n    const updateResult = await updateResponse.json();\n    console.log('Notion 페이지 업데이트 성공:', updateResult.id);\n    \n    res.json({ \n      success: true, \n      message: '성공적으로 업데이트되었습니다.',\n      pageId: updateResult.id,\n      property: propertyName,\n      newValue: newValue,\n      updatedAt: new Date().toISOString()\n    });\n    \n  } catch (error) {\n    console.error('숙제 업데이트 오류:', error);\n    console.error('오류 상세:', error.message);\n    \n    res.status(500).json({ \n      success: false, \n      message: '서버 오류가 발생했습니다.',\n      error: error.message \n    });\n  }\n});\n\n// Vercel 배포용 기본 handler\nexport default app;\n\n// 로컬 개발환경에서만 실행\nif (process.env.NODE_ENV !== 'production') {\n  app.listen(PORT, () => {\n    console.log(`학습 플래너 서버가 포트 ${PORT}에서 실행 중입니다!`);\n    console.log(`학생용: http://localhost:${PORT}`);\n    console.log(`선생님용: http://localhost:${PORT}/teacher`);\n    \n    // Notion 연결 상태 확인\n    console.log('처우 Notion 연결 상태를 확인중...');\n    getAccessToken()\n      .then(() => console.log('✓ Notion 연결 성공!'))\n      .catch(err => console.error('✗ Notion 연결 실패:', err.message));\n  });\n}","size_bytes":29431}},"version":1}